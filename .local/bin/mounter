#!/bin/bash
## 2025-08-20   SARBS - ASCII-Marker Edition
## Mountet Android-Telefone und USB-Laufwerke (verschlÃ¼sselt oder nicht)
## WICHTIG: Nutzt ASCII-Marker [TYPE] statt Emojis fÃ¼r PortabilitÃ¤t!
## Die Marker bestimmen die Mount-Logik und Optionen.
## Dependencies: dmenu, simple-mtpfs (fÃ¼r Android), cryptsetup (fÃ¼r LUKS)
## Sudoers-EintrÃ¤ge nÃ¶tig fÃ¼r: mount, umount, cryptsetup, mkdir in /mnt

IFS='
'

# Funktion zum Escapen von Handy-Namen fÃ¼r sichere Filesystem-Namen
# Entfernt Sonderzeichen und konvertiert zu ASCII
escape() {
    echo "$@" | iconv -cf UTF-8 -t ASCII//TRANSLIT | tr -d '[:punct:]' | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed "s/-\+/-/g;s/\(^-\|-\$\)//g"
}

# GerÃ¤tetyp-Erkennung basierend auf Device-Namen und System-Info
# Returnt: NVME, DVD, USB, SSD, HDD oder DISK
get_device_type() {
    local device="$1"
    local base="${device##*/}"  # Nur der Device-Name ohne /dev/

    # NVMe-SSDs erkennen (z.B. nvme0n1p1)
    [[ "$base" =~ nvme ]] && echo "NVME" && return

    # Optische Laufwerke (sr0, sr1, etc.)
    [[ "$base" =~ sr[0-9]+ ]] && echo "DVD" && return

    # Basis-Device fÃ¼r weitere Checks vorbereiten
    # Bei NVMe: nvme0n1p1 -> nvme0n1, bei anderen: sda1 -> sda
    [[ "$base" =~ nvme[0-9]+n[0-9]+p[0-9]+ ]] && base="${base%p[0-9]*}" || base="${base%[0-9]*}"

    # Check ob rotational (HDD) oder nicht (SSD) via /sys
    if [ -f "/sys/block/$base/queue/rotational" ]; then
        rot=$(cat "/sys/block/$base/queue/rotational")      # 0=SSD, 1=HDD
        rem=$(cat "/sys/block/$base/removable" 2>/dev/null || echo "0")  # 1=USB
        [ "$rem" = "1" ] && echo "USB" && return
        [ "$rot" = "0" ] && echo "SSD" || echo "HDD"
    else
        echo "DISK"  # Fallback wenn keine Info verfÃ¼gbar
    fi
}

# ========== ANDROID/MTP DEVICES ==========
# Listet alle MTP-GerÃ¤te und markiert sie mit [HANDY]
phones="$(simple-mtpfs -l 2>/dev/null | sed "s/^/[HANDY] /")"

# Bereits gemountete Handys aus der Liste entfernen
mountedphones="$(grep "simple-mtpfs" /etc/mtab)"
[ -n "$mountedphones" ] && phones="$(for phone in $phones; do
    escphone="$(escape "${phone#*] }")"
    echo "$mountedphones" | grep -q "$escphone" || echo "$phone"
done)"

# ========== LUKS ENCRYPTED DRIVES ==========
# Alle LUKS-Laufwerke finden (brauchen UUID zum Check ob bereits entschlÃ¼sselt)
allluks="$(lsblk -rpo "uuid,name,type,size,label,mountpoint,fstype" | grep crypto_LUKS)"

# Bereits entschlÃ¼sselte LUKS devices finden
decrypted="$(find /dev/disk/by-id/dm-uuid-CRYPT-LUKS2-* 2>/dev/null | sed "s|.*LUKS2-||;s|-.*||")"

# Nur nicht-entschlÃ¼sselte LUKS anzeigen
unopenedluks="$(for drive in $allluks; do
    uuid="${drive%% *}"
    uuid="${uuid//-}"  # Bindestriche aus UUID entfernen fÃ¼r Vergleich

    # Skip wenn bereits entschlÃ¼sselt
    if [ -n "$decrypted" ]; then
        echo "$decrypted" | grep -q "$uuid" && continue
    fi

    # Format: [LUKS ] device (size) label/fstype
    echo "$drive" | sed 's/ /:/g' | awk -F: '{
        if ($1 == "") {
            # Keine UUID (sollte bei LUKS nicht vorkommen)
            printf "[LUKS ] %s (%s) %s\n", $2, $4, $7
        } else {
            # Mit UUID (normal)
            printf "[LUKS ] %s (%s) %s\n", $2, $4, $7
        }
    }'
done)"

# ========== NORMALE PARTITIONEN ==========
# WICHTIG: Ohne UUID-Feld! Das verschiebt nur die Felder wenn UUID fehlt
# Format: name type size label mountpoint fstype
normalparts="$(lsblk -rpo "name,type,size,label,mountpoint,fstype" | grep -v crypto_LUKS | grep 'part\|rom' | while read -r line; do
    # Felder direkt parsen - Position ist jetzt fest!
    name=$(echo "$line" | awk '{print $1}')      # Device-Pfad
    type=$(echo "$line" | awk '{print $2}')      # part/rom/etc
    size=$(echo "$line" | awk '{print $3}')      # GrÃ¶ÃŸe
    label=$(echo "$line" | awk '{print $4}')     # Label (optional)
    mountpoint=$(echo "$line" | awk '{print $5}') # Mountpoint (leer wenn unmounted)
    fstype=$(echo "$line" | awk '{print $6}')    # Filesystem-Typ

    # Nur unmountete Devices anzeigen
    if [ -z "$mountpoint" ]; then
        # Device-Typ ermitteln (USB/SSD/HDD/etc)
        dtype=$(get_device_type "$name")

        # Beschreibung: Label > Filesystem > Device-Name
        desc="${label:-${fstype:-${name##*/}}}"

        # Format: [TYPE  ] /dev/xxx (size) description
        printf "[%-5s] %s (%s) %s\n" "$dtype" "$name" "$size" "$desc"
    fi
done)"

# ========== ALLES ZUSAMMENFÃœGEN ==========
alldrives="$(echo "$phones
$unopenedluks
$normalparts" | sed "/^$/d")"  # Leere Zeilen entfernen

# Beende wenn keine Laufwerke gefunden
set -e
test -n "$alldrives"

# ========== DMENU AUSWAHL ==========
chosen="$(echo "$alldrives" | dmenu -l 10 -p "Welches Laufwerk mounten?" -i)"

# ========== PARSE DIE AUSWAHL ==========
# Der Marker [TYPE] bestimmt die Mount-Logik!
marker="${chosen%%]*}"         # Alles vor ]
marker="${marker#[}"           # [ entfernen
marker="${marker// /}"         # Spaces entfernen

# Device-Pfad ist zwischen "] " und " ("
device="${chosen#*] }"         # Alles nach "] "
device="${device%% (*}"        # Alles vor " ("

# ========== HILFSFUNKTIONEN ==========

# Mountpunkt via dmenu wÃ¤hlen lassen
getmount() {
    mp="$(find /mnt /media /mount /home -maxdepth 1 -type d 2>/dev/null | dmenu -l 10 -i -p "Mountpunkt wÃ¤hlen:")"
    test -n "$mp"
    if [ ! -d "$mp" ]; then
        mkdiryn=$(printf "Nein\\nJa" | dmenu -i -p "$mp existiert nicht. Erstellen?")
        [ "$mkdiryn" = "Ja" ] && (mkdir -p "$mp" || sudo -A mkdir -p "$mp")
    fi
}

# Versuche mount ohne spezifischen Mountpunkt (nutzt fstab wenn vorhanden)
attemptmount() {
    if sudo -A mount "$1" 2>/dev/null; then
        notify-send "âœ“ Laufwerk gemountet" "$1 gemountet."
        exit
    else
        return 1
    fi
}

# ========== HAUPTLOGIK - Marker-basierte Aktionen ==========
case "$marker" in
    HDD|SSD|USB|NVME|DVD|DISK)
        # Normale Laufwerke
        if attemptmount "$device"; then
            exit
        else
            getmount

            # Device-spezifische Mount-Optionen
            case "$marker" in
                USB|HDD)
                    # sync fÃ¼r sicheres Entfernen bei USB/HDD
                    opts="uid=$(id -u),gid=$(id -g),sync"
                    ;;
                SSD|NVME)
                    # noatime reduziert SchreibvorgÃ¤nge auf SSDs
                    opts="uid=$(id -u),gid=$(id -g),noatime"
                    ;;
                DVD)
                    # Read-only fÃ¼r optische Medien
                    opts="ro,uid=$(id -u),gid=$(id -g)"
                    ;;
                *)
                    # Standard-Optionen
                    opts="uid=$(id -u),gid=$(id -g)"
                    ;;
            esac

            # Mount mit spezifischen Optionen
            sudo -A mount "$device" "$mp" -o "$opts" || {
                notify-send "âœ— Fehler" "Mount fehlgeschlagen fÃ¼r $device"
                exit 1
            }
            notify-send "âœ“ $marker gemountet" "$device zu $mp gemountet."
        fi
        ;;

    LUKS)
        # VerschlÃ¼sselte Laufwerke - automatisch nach /mnt/usb[num]

        # Freie Nummer fÃ¼r mapper-Device finden
        num=0
        while [ -e "/dev/mapper/usb$num" ]; do
            num=$((num + 1))
        done

        # EntschlÃ¼sseln in separatem Terminal fÃ¼r Passwort-Eingabe
        # WICHTIG: cryptsetup braucht NOPASSWD in sudoers!
        ${TERMINAL:-st} -n floatterm -g 70x2 -f "Liberation Mono:size=16" \
            -e sudo cryptsetup open "$device" "usb$num"

        if [ -b "/dev/mapper/usb$num" ]; then
            # LUKS devices immer nach /mnt/usb[num] mounten
            mp="/mnt/usb$num"
            [ ! -d "$mp" ] && sudo -A mkdir -p "$mp"

            sudo -A mount "/dev/mapper/usb$num" "$mp" || {
                notify-send "âœ— Fehler" "Mount fehlgeschlagen"
                sudo cryptsetup close "usb$num"
                exit 1
            }
            notify-send "âœ“ LUKS gemountet" "$device zu $mp gemountet."
        else
            notify-send "âœ— Fehler" "EntschlÃ¼sselung fehlgeschlagen"
            exit 1
        fi
        ;;

    HANDY)
        # Android/MTP GerÃ¤te
        notify-send "ðŸ“± Hinweis" "Erlaube Dateizugriff auf dem Handy"
        getmount

        # Device-Nummer aus der MTP-Liste extrahieren
        number="${chosen#*] }"
        number="${number%%:*}"

        # MTP mount mit simple-mtpfs
        sudo -A simple-mtpfs -o allow_other \
            -o fsname="simple-mtpfs-$(escape "$chosen")" \
            --device "$number" "$mp" || {
            notify-send "âœ— Fehler" "Mount fehlgeschlagen"
            exit 1
        }
        notify-send "âœ“ Handy gemountet" "Android zu $mp gemountet"
        ;;

    *)
        # Unbekannter Marker - sollte nicht vorkommen
        notify-send "âœ— Fehler" "Unbekannter Typ: $marker"
        exit 1
        ;;
esac
