#!/bin/bash
## 2025-08-29   SARBS - ASCII-Marker mit Phyton parsing
## Mountet Android-Telefone und USB-Laufwerke (verschlüsselt oder nicht)
## WICHTIG: Nutzt ASCII-Marker [TYPE] statt Emojis für Portabilität!
## Die Marker bestimmen die Mount-Logik und Optionen.
## Dependencies: dmenu, simple-mtpfs (für Android), cryptsetup (für LUKS)
## Sudoers-Einträge nötig für: mount, umount, cryptsetup, mkdir in /mnt

IFS='
'

# Funktion zum Escapen von Handy-Namen für sichere Filesystem-Namen
# Entfernt Sonderzeichen und konvertiert zu ASCII
escape() {
    echo "$@" | iconv -cf UTF-8 -t ASCII//TRANSLIT | tr -d '[:punct:]' | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed "s/-\+/-/g;s/\(^-\|-\$\)//g"
}

# Gerätetyp-Erkennung basierend auf Device-Namen und System-Info
# Returnt: NVME, DVD, USB, SSD, HDD oder DISK
get_device_type() {
    local device="$1"
    local base="${device##*/}"  # Nur der Device-Name ohne /dev/

    # NVMe-SSDs erkennen (z.B. nvme0n1p1)
    [[ "$base" =~ nvme ]] && echo "NVME" && return

    # Optische Laufwerke (sr0, sr1, etc.)
    [[ "$base" =~ sr[0-9]+ ]] && echo "DVD" && return

    # Basis-Device für weitere Checks vorbereiten
    # Bei NVMe: nvme0n1p1 -> nvme0n1, bei anderen: sda1 -> sda
    [[ "$base" =~ nvme[0-9]+n[0-9]+p[0-9]+ ]] && base="${base%p[0-9]*}" || base="${base%[0-9]*}"

    # Check ob rotational (HDD) oder nicht (SSD) via /sys
    if [ -f "/sys/block/$base/queue/rotational" ]; then
        rot=$(cat "/sys/block/$base/queue/rotational" 2>/dev/null || echo "1")      # 0=SSD, 1=HDD
        rem=$(cat "/sys/block/$base/removable" 2>/dev/null || echo "0")  # 1=USB
        [ "$rem" = "1" ] && echo "USB" && return
        [ "$rot" = "0" ] && echo "SSD" || echo "HDD"
    else
        echo "DISK"  # Fallback wenn keine Info verfügbar
    fi
}

# ========== ANDROID/MTP DEVICES ==========
# Listet alle MTP-Geräte und markiert sie mit [HANDY]
phones="$(simple-mtpfs -l 2>/dev/null | sed "s/^/[HANDY] /")"

# Bereits gemountete Handys aus der Liste entfernen
mountedphones="$(grep "simple-mtpfs" /etc/mtab)"
[ -n "$mountedphones" ] && phones="$(for phone in $phones; do
    escphone="$(escape "${phone#*] }")"
    echo "$mountedphones" | grep -q "$escphone" || echo "$phone"
done)"

# ========== LUKS ENCRYPTED DRIVES ==========
# Alle LUKS-Laufwerke finden (brauchen UUID zum Check ob bereits entschlüsselt)
allluks="$(lsblk -rpo "uuid,name,type,size,label,mountpoint,fstype" | grep crypto_LUKS)"

# Bereits entschlüsselte LUKS devices finden
decrypted="$(find /dev/disk/by-id/dm-uuid-CRYPT-LUKS2-* 2>/dev/null | sed "s|.*LUKS2-||;s|-.*||")"

# Nur nicht-entschlüsselte LUKS anzeigen
unopenedluks="$(for drive in $allluks; do
    uuid="${drive%% *}"
    uuid="${uuid//-}"  # Bindestriche aus UUID entfernen für Vergleich

    # Skip wenn bereits entschlüsselt
    if [ -n "$decrypted" ]; then
        echo "$decrypted" | grep -q "$uuid" && continue
    fi

    # Format: [LUKS ] device (size) label/fstype
    echo "$drive" | sed 's/ /:/g' | awk -F: '{
        if ($1 == "") {
            # Keine UUID (sollte bei LUKS nicht vorkommen)
            printf "[LUKS ] %s (%s) %s\n", $2, $4, $7
        } else {
            # Mit UUID (normal)
            printf "[LUKS ] %s (%s) %s\n", $2, $4, $7
        }
    }'
done)"

# ========== NORMALE PARTITIONEN ==========
# FIX: Verwende JSON output für zuverlässiges Parsing
normalparts="$(lsblk -J -o name,type,size,label,mountpoint,fstype 2>/dev/null | \
    python3 -c "
import json, sys
data = json.load(sys.stdin)

def process_device(dev, parent_removable=False):
    results = []
    # Check if device is removable
    is_removable = parent_removable
    if 'children' not in dev:
        # For devices without children, check removable status
        try:
            with open(f'/sys/block/{dev[\"name\"]}/removable', 'r') as f:
                is_removable = f.read().strip() == '1'
        except:
            pass

    # Process children (partitions)
    if 'children' in dev:
        for child in dev['children']:
            if child.get('type') in ['part', 'rom']:
                # Skip if mounted or is crypto_LUKS
                if child.get('mountpoint') or child.get('fstype') == 'crypto_LUKS':
                    continue

                name = '/dev/' + child['name']
                size = child.get('size', 'N/A')
                label = child.get('label', '')
                fstype = child.get('fstype', '')

                # Determine device type
                if 'nvme' in child['name']:
                    dtype = 'NVME'
                elif child['type'] == 'rom':
                    dtype = 'DVD'
                elif is_removable:
                    dtype = 'USB'
                else:
                    # Check rotational for SSD/HDD
                    base = child['name'].rstrip('0123456789')
                    try:
                        with open(f'/sys/block/{base}/queue/rotational', 'r') as f:
                            dtype = 'HDD' if f.read().strip() == '1' else 'SSD'
                    except:
                        dtype = 'DISK'

                # Description: Label > Filesystem > Device-Name
                desc = label or fstype or child['name']

                results.append(f'[{dtype:<5}] {name} ({size}) {desc}')

    # Also check the device itself if it's a partition without children
    elif dev.get('type') in ['part', 'rom']:
        if not dev.get('mountpoint') and dev.get('fstype') != 'crypto_LUKS':
            name = '/dev/' + dev['name']
            size = dev.get('size', 'N/A')
            label = dev.get('label', '')
            fstype = dev.get('fstype', '')

            # Determine device type
            if 'nvme' in dev['name']:
                dtype = 'NVME'
            elif dev['type'] == 'rom':
                dtype = 'DVD'
            elif is_removable:
                dtype = 'USB'
            else:
                base = dev['name'].rstrip('0123456789')
                try:
                    with open(f'/sys/block/{base}/queue/rotational', 'r') as f:
                        dtype = 'HDD' if f.read().strip() == '1' else 'SSD'
                except:
                    dtype = 'DISK'

            desc = label or fstype or dev['name']
            results.append(f'[{dtype:<5}] {name} ({size}) {desc}')

    return results

# Process all block devices
for device in data.get('blockdevices', []):
    # Check if device is removable
    is_removable = False
    try:
        with open(f'/sys/block/{device[\"name\"]}/removable', 'r') as f:
            is_removable = f.read().strip() == '1'
    except:
        pass

    for line in process_device(device, is_removable):
        print(line)
" 2>/dev/null || \
    # Fallback to original method if Python fails
    lsblk -rpo "name,type,size,label,mountpoint,fstype" | grep -v crypto_LUKS | grep 'part\|rom' | while read -r line; do
        name=$(echo "$line" | awk '{print $1}')
        type=$(echo "$line" | awk '{print $2}')
        size=$(echo "$line" | awk '{print $3}')
        label=$(echo "$line" | awk '{print $4}')
        mountpoint=$(echo "$line" | awk '{print $5}')
        fstype=$(echo "$line" | awk '{print $6}')

        if [ -z "$mountpoint" ]; then
            dtype=$(get_device_type "$name")
            desc="${label:-${fstype:-${name##*/}}}"
            printf "[%-5s] %s (%s) %s\n" "$dtype" "$name" "$size" "$desc"
        fi
    done
)"

# ========== ALLES ZUSAMMENFÜGEN ==========
alldrives="$(echo "$phones
$unopenedluks
$normalparts" | sed "/^$/d")"  # Leere Zeilen entfernen

# Beende wenn keine Laufwerke gefunden
if [ -z "$alldrives" ]; then
    notify-send "ℹ️ Info" "Keine unmounted Laufwerke gefunden"
    exit 0
fi

# ========== DMENU AUSWAHL ==========
chosen="$(echo "$alldrives" | dmenu -l 10 -p "Welches Laufwerk mounten?" -i)"
[ -z "$chosen" ] && exit 0

# ========== PARSE DIE AUSWAHL ==========
# Der Marker [TYPE] bestimmt die Mount-Logik!
marker="${chosen%%]*}"         # Alles vor ]
marker="${marker#[}"           # [ entfernen
marker="${marker// /}"         # Spaces entfernen

# Device-Pfad ist zwischen "] " und " ("
device="${chosen#*] }"         # Alles nach "] "
device="${device%% (*}"        # Alles vor " ("

# ========== HILFSFUNKTIONEN ==========

# Mountpunkt via dmenu wählen lassen
getmount() {
    mp="$(find /mnt /media /mount /home -maxdepth 1 -type d 2>/dev/null | dmenu -l 10 -i -p "Mountpunkt wählen:")"
    test -n "$mp"
    if [ ! -d "$mp" ]; then
        mkdiryn=$(printf "Nein\\nJa" | dmenu -i -p "$mp existiert nicht. Erstellen?")
        [ "$mkdiryn" = "Ja" ] && (mkdir -p "$mp" || sudo -A mkdir -p "$mp")
    fi
}

# Versuche mount ohne spezifischen Mountpunkt (nutzt fstab wenn vorhanden)
attemptmount() {
    if sudo -A mount "$1" 2>/dev/null; then
        notify-send "✔ Laufwerk gemountet" "$1 gemountet."
        exit
    else
        return 1
    fi
}

# ========== HAUPTLOGIK - Marker-basierte Aktionen ==========
case "$marker" in
    HDD|SSD|USB|NVME|DVD|DISK)
        # Normale Laufwerke
        if attemptmount "$device"; then
            exit
        else
            getmount

            # Device-spezifische Mount-Optionen
            case "$marker" in
                USB|HDD)
                    # sync für sicheres Entfernen bei USB/HDD
                    opts="uid=$(id -u),gid=$(id -g),sync"
                    ;;
                SSD|NVME)
                    # noatime reduziert Schreibvorgänge auf SSDs
                    opts="uid=$(id -u),gid=$(id -g),noatime"
                    ;;
                DVD)
                    # Read-only für optische Medien
                    opts="ro,uid=$(id -u),gid=$(id -g)"
                    ;;
                *)
                    # Standard-Optionen
                    opts="uid=$(id -u),gid=$(id -g)"
                    ;;
            esac

            # Mount mit spezifischen Optionen
            sudo -A mount "$device" "$mp" -o "$opts" || {
                notify-send "✗ Fehler" "Mount fehlgeschlagen für $device"
                exit 1
            }
            notify-send "✔ $marker gemountet" "$device zu $mp gemountet."
        fi
        ;;

    LUKS)
        # Verschlüsselte Laufwerke - automatisch nach /mnt/usb[num]

        # Freie Nummer für mapper-Device finden
        num=0
        while [ -e "/dev/mapper/usb$num" ]; do
            num=$((num + 1))
        done

        # Entschlüsseln in separatem Terminal für Passwort-Eingabe
        # WICHTIG: cryptsetup braucht NOPASSWD in sudoers!
        ${TERMINAL:-st} -n floatterm -g 70x2 -f "Liberation Mono:size=16" \
            -e sudo cryptsetup open "$device" "usb$num"

        if [ -b "/dev/mapper/usb$num" ]; then
            # LUKS devices immer nach /mnt/usb[num] mounten
            mp="/mnt/usb$num"
            [ ! -d "$mp" ] && sudo -A mkdir -p "$mp"

            sudo -A mount "/dev/mapper/usb$num" "$mp" || {
                notify-send "✗ Fehler" "Mount fehlgeschlagen"
                sudo cryptsetup close "usb$num"
                exit 1
            }
            notify-send "✔ LUKS gemountet" "$device zu $mp gemountet."
        else
            notify-send "✗ Fehler" "Entschlüsselung fehlgeschlagen"
            exit 1
        fi
        ;;

    HANDY)
        # Android/MTP Geräte
        notify-send "📱 Hinweis" "Erlaube Dateizugriff auf dem Handy"
        getmount

        # Device-Nummer aus der MTP-Liste extrahieren
        number="${chosen#*] }"
        number="${number%%:*}"

        # MTP mount mit simple-mtpfs
        sudo -A simple-mtpfs -o allow_other \
            -o fsname="simple-mtpfs-$(escape "$chosen")" \
            --device "$number" "$mp" || {
            notify-send "✗ Fehler" "Mount fehlgeschlagen"
            exit 1
        }
        notify-send "✔ Handy gemountet" "Android zu $mp gemountet"
        ;;

    *)
        # Unbekannter Marker - sollte nicht vorkommen
        notify-send "✗ Fehler" "Unbekannter Typ: $marker"
        exit 1
        ;;
esac
