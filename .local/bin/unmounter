#!/bin/sh
## 2025-10-31 SARBS - DEV
# Universelles Unmount-Skript mit Prozess-Management und intelligentem HDD-Poweroff
# - Interaktive Prozess-Behandlung
# - Sync vor Unmount
# - Intelligentes HDD Power-Management (USB-HDDs automatisch, interne HDDs konfigurierbar)
# - Kritische Benachrichtigungen

set -e

# Funktion f√ºr kritische Benachrichtigungen
notify_critical() {
    notify-send -u critical "$@"
}

# Funktion f√ºr normale Benachrichtigungen
notify_normal() {
    notify-send -u normal "$@"
}

# Prozesse anzeigen und optional beenden
handle_processes_using_directory() {
    directory=$1

    # Verwende fuser f√ºr bessere Performance
    process_pids=$(fuser -v "$directory" 2>&1 | awk 'NR>1 {print $2}' | grep -E '^[0-9]+$' || true)

    if [ -n "$process_pids" ]; then
        # Prozess-Details sammeln
        process_details=""
        for pid in $process_pids; do
            if [ -d "/proc/$pid" ]; then
                cmd=$(ps -p "$pid" -o comm= 2>/dev/null || echo "unbekannt")
                process_details="${process_details}PID $pid: $cmd\n"
            fi
        done

        if [ -n "$process_details" ]; then
            notify_normal "‚ö†Ô∏è Prozesse verwenden $directory" "$(echo -e "$process_details")"

            # Interaktive Abfrage
            action=$(echo -e "Prozesse sanft beenden (SIGTERM)\nProzesse erzwingen (SIGKILL)\nAbbrechen" | \
                     dmenu -i -p "Prozesse blockieren das Aush√§ngen. Was tun?")

            case "$action" in
                "Prozesse sanft beenden"*)
                    echo "$process_pids" | xargs -r kill -15 2>/dev/null || true
                    sleep 2
                    # Pr√ºfen ob noch Prozesse laufen
                    remaining=$(fuser -v "$directory" 2>&1 | awk 'NR>1 {print $2}' | grep -E '^[0-9]+$' || true)
                    if [ -n "$remaining" ]; then
                        notify_normal "‚ö†Ô∏è Einige Prozesse laufen noch" "Versuche SIGKILL..."
                        echo "$remaining" | xargs -r kill -9 2>/dev/null || true
                    fi
                    notify_normal "‚úì Prozesse beendet" "Directory ist jetzt frei"
                    ;;
                "Prozesse erzwingen"*)
                    echo "$process_pids" | xargs -r kill -9 2>/dev/null || true
                    notify_critical "‚ö†Ô∏è Prozesse gekillt" "Du Monster! üëπ"
                    ;;
                "Abbrechen")
                    notify_normal "Abgebrochen" "Unmount wurde abgebrochen"
                    exit 0
                    ;;
            esac
        fi
    fi
}

# Pr√ºft ob Ger√§t eine rotierende HDD ist
is_rotating_disk() {
    device=$1
    # Entferne partition nummer falls vorhanden (sda1 -> sda)
    base_device=$(echo "$device" | sed 's/[0-9]*$//')

    if [ -f "/sys/block/${base_device}/queue/rotational" ]; then
        rotational=$(cat "/sys/block/${base_device}/queue/rotational" 2>/dev/null || echo "0")
        [ "$rotational" = "1" ]
    else
        false
    fi
}

# Pr√ºft ob Ger√§t ein USB-Ger√§t ist
is_usb_device() {
    device=$1
    base_device=$(echo "$device" | sed 's/[0-9]*$//')

    # Pr√ºfe removable flag
    if [ -f "/sys/block/${base_device}/removable" ]; then
        removable=$(cat "/sys/block/${base_device}/removable" 2>/dev/null || echo "0")
        [ "$removable" = "1" ] && return 0
    fi

    # Alternative: Pr√ºfe ob Device-Pfad "usb" enth√§lt
    device_path=$(readlink -f "/sys/block/${base_device}" 2>/dev/null || echo "")
    echo "$device_path" | grep -q "/usb"
}

# L√§dt Poweroff-Policy aus Config
load_poweroff_policy() {
    config_file="${XDG_CONFIG_HOME:-$HOME/.config}/unmounter/config"

    if [ -f "$config_file" ]; then
        # shellcheck disable=SC1090
        . "$config_file"
    fi

    # Standard: auto (USB-HDDs automatisch, interne HDDs fragen)
    POWEROFF_POLICY="${POWEROFF_POLICY:-auto}"
}

# Speichert Poweroff-Policy
save_poweroff_policy() {
    policy=$1
    config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/unmounter"
    config_file="$config_dir/config"

    mkdir -p "$config_dir"
    echo "POWEROFF_POLICY=$policy" > "$config_file"
}

# HDD sicher herunterfahren
poweroff_hdd() {
    device=$1
    base_device=$(echo "$device" | sed 's/[0-9]*$//')

    notify_normal "üíæ HDD wird heruntergefahren..." "/dev/${base_device}"

    # Erst sync, dann hdparm
    sync
    if command -v hdparm >/dev/null 2>&1; then
        sudo -A hdparm -Y "/dev/${base_device}" 2>/dev/null || true
        notify_normal "‚úì HDD heruntergefahren" "/dev/${base_device} ist jetzt im Standby"
    else
        notify_critical "‚ö†Ô∏è hdparm nicht installiert" "HDD konnte nicht heruntergefahren werden"
    fi
}

# Hauptskript
mounteddroids="$(grep simple-mtpfs /etc/mtab 2>/dev/null | awk '{print "üì±" $2}' || true)"
lsblkoutput="$(lsblk -nrpo "name,type,size,mountpoint" 2>/dev/null || true)"
mounteddrives="$(echo "$lsblkoutput" | awk '($2=="part"||$2=="crypt")&&$4!~/\/boot|\/home$|SWAP/&&length($4)>1{printf "üíæ%s (%s)\n",$4,$3}')"

allunmountable="$(echo "$mounteddroids
$mounteddrives" | sed "/^$/d;s/ *$//")"

if [ -z "$allunmountable" ]; then
    notify_normal "Keine Laufwerke zum Aush√§ngen" "Es sind keine aush√§ngbaren Laufwerke eingeh√§ngt"
    exit 1
fi

chosen="$(echo "$allunmountable" | dmenu -i -p "Welches Laufwerk aush√§ngen?")"
[ -z "$chosen" ] && exit 0

chosen="${chosen%% *}"
# Verzeichnispfad extrahieren
mountpoint="/${chosen#*/}"

# Prozesse behandeln
handle_processes_using_directory "$mountpoint"

# Sync durchf√ºhren mit Benachrichtigung
notify_normal "üîÑ Synchronisiere Daten..." "Stelle sicher, dass alle Daten geschrieben sind"
sync

# Device-Name f√ºr HDD-Check ermitteln
device_name=$(findmnt -n -o SOURCE "$mountpoint" 2>/dev/null | sed 's/.*\///' || true)

# Laufwerk aush√§ngen
if sudo -A umount -l "$mountpoint" 2>/dev/null; then
    notify_normal "‚úì Ger√§t ausgeh√§ngt" "$chosen wurde erfolgreich ausgeh√§ngt"
else
    notify_critical "‚ùå Fehler beim Aush√§ngen" "Konnte $chosen nicht aush√§ngen"
    exit 1
fi

# LUKS schlie√üen falls verschl√ºsselt
cryptid="$(echo "$lsblkoutput" | grep "/${chosen#*/}$" | awk '{print $1}' || true)"
if [ -n "$cryptid" ] && [ -b "/dev/mapper/${cryptid##*/}" ]; then
    if sudo -A cryptsetup close "${cryptid##*/}" 2>/dev/null; then
        notify_normal "üîí Verschl√ºsselung geschlossen" "LUKS-Container ist wieder sicher verschlossen"
    fi
fi

# HDD herunterfahren falls es eine rotierende Disk ist
if [ -n "$device_name" ] && is_rotating_disk "$device_name"; then
    base_device=$(echo "$device_name" | sed 's/[0-9]*$//')

    # Lade Policy-Einstellungen
    load_poweroff_policy

    # USB-HDD? -> Automatisch herunterfahren (au√üer Policy=never)
    if is_usb_device "$device_name"; then
        if [ "$POWEROFF_POLICY" != "never" ]; then
            notify_normal "üí° USB-HDD erkannt" "Wird automatisch heruntergefahren"
            poweroff_hdd "$device_name"
        fi
    # Interne HDD -> Je nach Policy handeln
    else
        case "$POWEROFF_POLICY" in
            always)
                poweroff_hdd "$device_name"
                ;;
            never)
                # Nichts tun
                ;;
            auto|*)
                # Frage mit erweiterten Optionen
                device_info=$(lsblk -ndo MODEL,SIZE "/dev/${base_device}" 2>/dev/null || echo "Unbekannt")
                choice=$(printf "Ja\nNein\nImmer automatisch\nNie automatisch" | \
                         dmenu -i -p "Interne HDD herunterfahren? ($device_info)")

                case "$choice" in
                    "Ja")
                        poweroff_hdd "$device_name"
                        ;;
                    "Immer automatisch")
                        save_poweroff_policy "always"
                        poweroff_hdd "$device_name"
                        notify_normal "‚öôÔ∏è Einstellung gespeichert" "HDDs werden ab jetzt immer automatisch heruntergefahren"
                        ;;
                    "Nie automatisch")
                        save_poweroff_policy "never"
                        notify_normal "‚öôÔ∏è Einstellung gespeichert" "HDDs werden nicht mehr heruntergefahren"
                        ;;
                esac
                ;;
        esac
    fi
fi

# Finale Best√§tigung
notify_normal "‚úÖ Vorgang abgeschlossen" "Das Ger√§t kann jetzt sicher entfernt werden"
