#!/bin/sh
## 2025-07-11 SARBS - DEV
# Universelles Unmount-Skript mit Prozess-Management und HDD-Poweroff
# - Interaktive Prozess-Behandlung
# - Sync vor Unmount
# - HDD Power-Management
# - Kritische Benachrichtigungen

set -e

# Farben fÃ¼r dmenu (optional, falls dein dmenu das unterstÃ¼tzt)
DMENU_NORMAL="#ebdbb2"
DMENU_SELECT="#458588"

# Funktion fÃ¼r kritische Benachrichtigungen
notify_critical() {
    notify-send -u critical "$@"
}

# Funktion fÃ¼r normale Benachrichtigungen
notify_normal() {
    notify-send -u normal "$@"
}

# Prozesse anzeigen und optional beenden
handle_processes_using_directory() {
    directory=$1

    # Verwende fuser fÃ¼r bessere Performance
    process_pids=$(fuser -v "$directory" 2>&1 | awk 'NR>1 {print $2}' | grep -E '^[0-9]+$' || true)

    if [ -n "$process_pids" ]; then
        # Prozess-Details sammeln
        process_details=""
        for pid in $process_pids; do
            if [ -d "/proc/$pid" ]; then
                cmd=$(ps -p "$pid" -o comm= 2>/dev/null || echo "unbekannt")
                process_details="${process_details}PID $pid: $cmd\n"
            fi
        done

        if [ -n "$process_details" ]; then
            notify_normal "âš ï¸ Prozesse verwenden $directory" "$(echo -e "$process_details")"

            # Interaktive Abfrage
            action=$(echo -e "Prozesse sanft beenden (SIGTERM)\nProzesse erzwingen (SIGKILL)\nAbbrechen" | \
                     dmenu -i -p "Prozesse blockieren das AushÃ¤ngen. Was tun?")

            case "$action" in
                "Prozesse sanft beenden"*)
                    echo "$process_pids" | xargs -r kill -15 2>/dev/null || true
                    sleep 2
                    # PrÃ¼fen ob noch Prozesse laufen
                    remaining=$(fuser -v "$directory" 2>&1 | awk 'NR>1 {print $2}' | grep -E '^[0-9]+$' || true)
                    if [ -n "$remaining" ]; then
                        notify_normal "âš ï¸ Einige Prozesse laufen noch" "Versuche SIGKILL..."
                        echo "$remaining" | xargs -r kill -9 2>/dev/null || true
                    fi
                    notify_normal "âœ“ Prozesse beendet" "Directory ist jetzt frei"
                    ;;
                "Prozesse erzwingen"*)
                    echo "$process_pids" | xargs -r kill -9 2>/dev/null || true
                    notify_critical "âš ï¸ Prozesse gekillt" "Du Monster! ðŸ‘¹"
                    ;;
                "Abbrechen")
                    notify_normal "Abgebrochen" "Unmount wurde abgebrochen"
                    exit 0
                    ;;
            esac
        fi
    fi
}

# PrÃ¼ft ob GerÃ¤t eine rotierende HDD ist
is_rotating_disk() {
    device=$1
    # Entferne partition nummer falls vorhanden (sda1 -> sda)
    base_device=$(echo "$device" | sed 's/[0-9]*$//')

    if [ -f "/sys/block/${base_device}/queue/rotational" ]; then
        rotational=$(cat "/sys/block/${base_device}/queue/rotational" 2>/dev/null || echo "0")
        [ "$rotational" = "1" ]
    else
        false
    fi
}

# HDD sicher herunterfahren
poweroff_hdd() {
    device=$1
    base_device=$(echo "$device" | sed 's/[0-9]*$//')

    notify_normal "ðŸ’¾ HDD wird heruntergefahren..." "/dev/${base_device}"

    # Erst sync, dann hdparm
    sync
    if command -v hdparm >/dev/null 2>&1; then
        sudo -A hdparm -Y "/dev/${base_device}" 2>/dev/null || true
        notify_normal "âœ“ HDD heruntergefahren" "/dev/${base_device} ist jetzt im Standby"
    else
        notify_critical "âš ï¸ hdparm nicht installiert" "HDD konnte nicht heruntergefahren werden"
    fi
}

# Hauptskript
mounteddroids="$(grep simple-mtpfs /etc/mtab 2>/dev/null | awk '{print "ðŸ“±" $2}' || true)"
lsblkoutput="$(lsblk -nrpo "name,type,size,mountpoint" 2>/dev/null || true)"
mounteddrives="$(echo "$lsblkoutput" | awk '($2=="part"||$2=="crypt")&&$4!~/\/boot|\/home$|SWAP/&&length($4)>1{printf "ðŸ’¾%s (%s)\n",$4,$3}')"

allunmountable="$(echo "$mounteddroids
$mounteddrives" | sed "/^$/d;s/ *$//")"

if [ -z "$allunmountable" ]; then
    notify_normal "Keine Laufwerke zum AushÃ¤ngen" "Es sind keine aushÃ¤ngbaren Laufwerke eingehÃ¤ngt"
    exit 1
fi

chosen="$(echo "$allunmountable" | dmenu -i -p "Welches Laufwerk aushÃ¤ngen?")"
[ -z "$chosen" ] && exit 0

chosen="${chosen%% *}"
# Verzeichnispfad extrahieren
mountpoint="/${chosen#*/}"

# Prozesse behandeln
handle_processes_using_directory "$mountpoint"

# Sync durchfÃ¼hren mit Benachrichtigung
notify_normal "ðŸ”„ Synchronisiere Daten..." "Stelle sicher, dass alle Daten geschrieben sind"
sync

# Device-Name fÃ¼r HDD-Check ermitteln
device_name=$(findmnt -n -o SOURCE "$mountpoint" 2>/dev/null | sed 's/.*\///' || true)

# Laufwerk aushÃ¤ngen
if sudo -A umount -l "$mountpoint" 2>/dev/null; then
    notify_normal "âœ“ GerÃ¤t ausgehÃ¤ngt" "$chosen wurde erfolgreich ausgehÃ¤ngt"
else
    notify_critical "âŒ Fehler beim AushÃ¤ngen" "Konnte $chosen nicht aushÃ¤ngen"
    exit 1
fi

# LUKS schlieÃŸen falls verschlÃ¼sselt
cryptid="$(echo "$lsblkoutput" | grep "/${chosen#*/}$" | awk '{print $1}' || true)"
if [ -n "$cryptid" ] && [ -b "/dev/mapper/${cryptid##*/}" ]; then
    if sudo -A cryptsetup close "${cryptid##*/}" 2>/dev/null; then
        notify_normal "ðŸ”’ VerschlÃ¼sselung geschlossen" "LUKS-Container ist wieder sicher verschlossen"
    fi
fi

# HDD herunterfahren falls es eine rotierende Disk ist
if [ -n "$device_name" ] && is_rotating_disk "$device_name"; then
    # Frage ob HDD heruntergefahren werden soll
    if echo -e "Ja\nNein" | dmenu -i -p "HDD herunterfahren?" | grep -q "Ja"; then
        poweroff_hdd "$device_name"
    fi
fi

# Finale BestÃ¤tigung
notify_normal "âœ… Vorgang abgeschlossen" "Das GerÃ¤t kann jetzt sicher entfernt werden"
