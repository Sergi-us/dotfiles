#!/bin/sh
## 2025-07-17 SARBS - DEV
# Unmount-Skript mit interaktiver Prozess-Behandlung, LUKS-Support und HDD-Poweroff
# Optional f√ºr sudo-freie Nutzung:
# %wheel ALL=(ALL:ALL) NOPASSWD: /usr/bin/cryptsetup,/usr/bin/hdparm

set -e

# Benachrichtigungen - critical f√ºr wichtiges, normal f√ºr info
notify() { notify-send -u "$1" "$2" "$3"; }

# Prozesse die das Verzeichnis nutzen behandeln
handle_processes() {
    directory="$1"

    # Finde blockierende Prozesse (fuser ist schneller als lsof)
    pids=$(fuser -v "$directory" 2>&1 | awk 'NR>1 {print $2}' | grep -E '^[0-9]+$' || true)
    [ -z "$pids" ] && return 0

    # Sammle Prozess-Details f√ºr Anzeige
    details=""
    for pid in $pids; do
        [ -d "/proc/$pid" ] || continue
        cmd=$(ps -p "$pid" -o comm= 2>/dev/null || echo "unbekannt")
        details="${details}PID $pid: $cmd\n"
    done

    [ -z "$details" ] && return 0

    # Zeige blockierende Prozesse
    notify normal "‚ö†Ô∏è Prozesse blockieren $directory" "$(echo -e "$details")"

    # Interaktive Abfrage mit dmenu
    action=$(echo -e "Sanft beenden (SIGTERM)\nErzwingen (SIGKILL)\nAbbrechen" | \
             dmenu -i -p "Prozesse blockieren das Aush√§ngen. Was tun?")

    case "$action" in
        "Sanft beenden"*)
            echo "$pids" | xargs -r kill -15 2>/dev/null || true
            notify normal "üîÑ Sende SIGTERM..." "Warte auf sauberes Beenden"
            sleep 2

            # Pr√ºfe ob noch Prozesse laufen
            remaining=$(fuser -v "$directory" 2>&1 | awk 'NR>1 {print $2}' | grep -E '^[0-9]+$' || true)
            if [ -n "$remaining" ]; then
                notify normal "‚ö†Ô∏è Einige Prozesse laufen noch" "Versuche SIGKILL..."
                echo "$remaining" | xargs -r kill -9 2>/dev/null || true
                sleep 1
            fi
            notify normal "‚úì Prozesse beendet" "Verzeichnis ist jetzt frei"
            ;;

        "Erzwingen"*)
            echo "$pids" | xargs -r kill -9 2>/dev/null || true
            notify normal "üíÄ Prozesse gekillt" "SIGKILL ausgef√ºhrt"
            sleep 1
            ;;

        *)
            notify normal "‚ùå Abgebrochen" "Unmount wurde abgebrochen"
            exit 0
            ;;
    esac
}

# Pr√ºft ob Ger√§t eine rotierende HDD ist
is_rotating_disk() {
    device="$1"
    base=$(echo "$device" | sed 's/[0-9]*$//')  # sda1 -> sda

    [ -f "/sys/block/$base/queue/rotational" ] || return 1
    [ "$(cat "/sys/block/$base/queue/rotational" 2>/dev/null)" = "1" ]
}

# HDD sicher herunterfahren
poweroff_hdd() {
    device="$1"
    base=$(echo "$device" | sed 's/[0-9]*$//')

    notify normal "üíæ HDD wird heruntergefahren..." "/dev/$base"

    # Erst hdparm versuchen
    if command -v hdparm >/dev/null 2>&1; then
        if sudo -A hdparm -Y "/dev/$base" 2>/dev/null; then
            sleep 1
            # Verify status
            status=$(sudo hdparm -C "/dev/$base" 2>&1 | grep -o "standby\|active" || echo "unknown")
            notify critical "üíæ HDD Status: $status" "/dev/$base nach hdparm -Y"

            # Falls noch active, versuche udisksctl
            if [ "$status" = "active" ] && command -v udisksctl >/dev/null 2>&1; then
                notify normal "üîÑ Versuche udisksctl..." "Alternative Methode"
                sudo -A udisksctl power-off -b "/dev/$base" 2>/dev/null || true
            fi
        else
            notify critical "‚ö†Ô∏è HDD Poweroff fehlgeschlagen" "Konnte /dev/$base nicht herunterfahren"
        fi
    else
        notify critical "‚ö†Ô∏è hdparm nicht installiert" "HDD konnte nicht heruntergefahren werden"
    fi
}

# === Hauptprogramm ===

# Sammle gemountete Ger√§te
droids="$(grep simple-mtpfs /etc/mtab 2>/dev/null | awk '{print "üì±" $2}' || true)"
lsblk="$(lsblk -nrpo "name,type,size,mountpoint" 2>/dev/null || true)"
drives="$(echo "$lsblk" | awk '($2=="part"||$2=="crypt")&&$4!~/\/boot|\/home$|SWAP/&&length($4)>1{printf "üíæ%s (%s)\n",$4,$3}')"

# Kombiniere alle aush√§ngbaren Ger√§te
unmountable="$(echo "$droids
$drives" | sed "/^$/d;s/ *$//")"

# Pr√ºfe ob es was zum Aush√§ngen gibt
if [ -z "$unmountable" ]; then
    notify critical "Keine Laufwerke" "Es sind keine aush√§ngbaren Laufwerke eingeh√§ngt"
    exit 1
fi

# Zeige Auswahl mit dmenu
chosen="$(echo "$unmountable" | dmenu -i -p "Welches Laufwerk aush√§ngen?")" || exit 0
chosen="${chosen%% *}"
mountpoint="/${chosen#*/}"

# Behandle blockierende Prozesse (inklusive cwd-Check)
handle_processes "$mountpoint"

# Extra-Check f√ºr Prozesse mit cwd im mountpoint
cwd_pids=$(lsof +d "$mountpoint" 2>/dev/null | awk 'NR>1 {print $2}' | sort -u | grep -E '^[0-9]+

# Synchronisiere Dateisystem
notify normal "üîÑ Synchronisiere..." "Stelle sicher, dass alle Daten geschrieben sind"
sync

# Device-Name f√ºr sp√§tere HDD/LUKS Checks ermitteln
device_name=$(findmnt -n -o SOURCE "$mountpoint" 2>/dev/null | sed 's/.*\///' || true)

# Versuche auszuh√§ngen (OHNE -l f√ºr sicheres LUKS schlie√üen!)
if sudo -A umount "$mountpoint" 2>/dev/null; then
    notify critical "‚úì Ausgeh√§ngt" "$mountpoint wurde erfolgreich ausgeh√§ngt"
else
    notify critical "‚ùå Fehler beim Aush√§ngen" "Konnte $mountpoint nicht aush√§ngen"
    exit 1
fi

# LUKS Container schlie√üen falls verschl√ºsselt
cryptdev="$(echo "$lsblk" | grep "$mountpoint$" | awk '{print $1}' || true)"
if [ -n "$cryptdev" ] && [ -b "/dev/mapper/${cryptdev##*/}" ]; then
    # Kurz warten damit Kernel alles freigibt
    sleep 1

    if sudo -A cryptsetup close "${cryptdev##*/}" 2>/dev/null; then
        notify critical "üîí Verschl√ºsselt" "LUKS-Container wurde sicher geschlossen"
    else
        # Falls es nicht klappt, Hinweis f√ºr manuelles Schlie√üen
        notify critical "‚ö†Ô∏è LUKS noch offen" "Manuell schlie√üen: sudo cryptsetup close ${cryptdev##*/}"
    fi
fi

# HDD herunterfahren falls es eine rotierende Disk ist
if [ -n "$device_name" ] && is_rotating_disk "$device_name"; then
    if echo -e "Ja\nNein" | dmenu -i -p "HDD herunterfahren?" | grep -q "Ja"; then
        poweroff_hdd "$device_name"
    fi
fi

# Finale Best√§tigung
notify critical "‚úÖ Fertig" "Das Ger√§t kann jetzt sicher entfernt werden" || true)
if [ -n "$cwd_pids" ]; then
    notify normal "üìÅ Prozesse mit Working Directory" "Diese Prozesse sind noch im Verzeichnis"
    # Zeige die selbe Auswahl wie oben
    handle_processes "$mountpoint"
fi

# Synchronisiere Dateisystem
notify normal "üîÑ Synchronisiere..." "Stelle sicher, dass alle Daten geschrieben sind"
sync

# Device-Name f√ºr sp√§tere HDD/LUKS Checks ermitteln
device_name=$(findmnt -n -o SOURCE "$mountpoint" 2>/dev/null | sed 's/.*\///' || true)

# Versuche auszuh√§ngen (OHNE -l f√ºr sicheres LUKS schlie√üen!)
if sudo -A umount "$mountpoint" 2>/dev/null; then
    notify critical "‚úì Ausgeh√§ngt" "$mountpoint wurde erfolgreich ausgeh√§ngt"
else
    notify critical "‚ùå Fehler beim Aush√§ngen" "Konnte $mountpoint nicht aush√§ngen"
    exit 1
fi

# LUKS Container schlie√üen falls verschl√ºsselt
cryptdev="$(echo "$lsblk" | grep "$mountpoint$" | awk '{print $1}' || true)"
if [ -n "$cryptdev" ] && [ -b "/dev/mapper/${cryptdev##*/}" ]; then
    # Kurz warten damit Kernel alles freigibt
    sleep 1

    if sudo -A cryptsetup close "${cryptdev##*/}" 2>/dev/null; then
        notify critical "üîí Verschl√ºsselt" "LUKS-Container wurde sicher geschlossen"
    else
        # Falls es nicht klappt, Hinweis f√ºr manuelles Schlie√üen
        notify critical "‚ö†Ô∏è LUKS noch offen" "Manuell schlie√üen: sudo cryptsetup close ${cryptdev##*/}"
    fi
fi

# HDD herunterfahren falls es eine rotierende Disk ist
if [ -n "$device_name" ] && is_rotating_disk "$device_name"; then
    if echo -e "Ja\nNein" | dmenu -i -p "HDD herunterfahren?" | grep -q "Ja"; then
        poweroff_hdd "$device_name"
    fi
fi

# Finale Best√§tigung
notify critical "‚úÖ Fertig" "Das Ger√§t kann jetzt sicher entfernt werden"
