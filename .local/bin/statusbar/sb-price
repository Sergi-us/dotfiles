#!/bin/sh
## 2025-11-17   SARBS

# Cryptocurrency Price Checker
# SARBS 09.11.2024
#
# Beschreibung:
# Dieses Skript ruft Kryptowährungspreise von rate.sx ab und zeigt sie formatiert an.
# TODO rate.sx kommt mit $ als Standartwährung daher, eine umstellung auf eur ist mir nicht gelungen
# Es speichert auch Preishistorien und kann Preisgrafiken anzeigen.
#
# Verwendung:
#   price <Basiswährung-Zierwährung> <"Währungsname"> <Icon>
#
# Beispiel:
#   price bat-usd "Basic Attention Token" 󰞘
#   Zeigt den BAT-Preis in USD an
#
# Parameter:
#   $1 - Währungspaar (z.B. 'btc-usd', 'eth-eur')
#   $2 - Anzeigename der Währung (optional, Standard ist $1)
#   $3 - Anzeigesymbol (optional, Standard ist 󰠓)

# Überprüfung auf erforderliche Parameter
[ -z "$1" ] && exit 1

# Grundlegende Konfiguration
url="${CRYPTOURL:-rate.sx}"
target="${1%%-*}"
denom="${1##*-}"
name="${2:-$1}"
icon="${3:-󰠓}"

# Icon-Mapping für Nerd Font Symbole
# Ersetzt problematische Unicode-Symbole durch Nerd Font Varianten
case "$icon" in
	"₿"|"21") icon="󰠓" ;;  # Bitcoin Nerd Font Symbol (nf-md-bitcoin)
	"Ξ"|"23") icon="󰠗" ;;  # Ethereum Nerd Font Symbol (nf-md-ethereum)
	"Ɱ"|"24") icon="" ;;  # Monero Nerd Font Symbol (nf-md-xmr)
	"₮") icon="" ;;       # Tether (nutze Bitcoin-Icon als Fallback)
	*) ;;                  # Behalte Original-Icon
esac
# Währungssymbol-Konfiguration
case "$denom" in
	"$target"|usd) denom="usd"; symb="$" ;;
	gbp) symb="£" ;;
	eur) symb="€" ;;
	btc) symb="₿" ;;
	*) denom="eur"; symb="€" ;; # Fallback zu Euro als Standardwährung
esac

# Konfiguration für Preishistorie ("@1M" = Monatshistorie)
interval="@1M"	# History contained in chart preceded by '@' (7d = 7 days)

# Verzeichnis- und Dateikonfiguration
dir="${XDG_CACHE_HOME:-$HOME/.cache}/crypto-prices"
pricefile="$dir/$target-$denom"
chartfile="$dir/$target-$denom-chart"

# Prüfe letzte Aktualisierung
filestat="$(stat -c %x "$pricefile" 2>/dev/null)"

# Erstelle Cache-Verzeichnis falls nicht vorhanden
[ -d "$dir" ] || mkdir -p "$dir"

# Funktion zum Aktualisieren der Preisdaten
updateprice() { curl -sf \
	--fail-early "${denom}.${url}/1${target}" "${denom}.${url}/${target}${interval}" \
	--output "$pricefile" --output "$chartfile" ||
	rm -f "$pricefile" "$chartfile" ;}

# Prüfe ob Update notwendig (einmal täglich)
[ "${filestat%% *}" != "$(date '+%Y-%m-%d')" ] &&
	updateme="1"

# Behandlung von Mausklicks
case $BLOCK_BUTTON in
    1) notify-send -u low "$icon Aktualisierung..." "Aktualisiere $name Preis..."
        updateme="1"
        showupdate="1" ;;
	2) setsid "$TERMINAL" -e less -Srf "$chartfile" ;;
    3) uptime="$(date -d "$filestat" '+%D at %T' | sed "s|$(date '+%D')|Heute|")"
       notify-send "$icon $name Modul" "\- <b>Exakter Preis: \$$(cat "$pricefile")</b>
- M-Klick für Preisverlauf
- L-Klick zum Aktualisieren
- Zeigt 󰋚 während der Aktualisierung
- <b>Letzte Aktualisierung:
    $uptime</b>" ;;
    4) ;;
    5) ;;
	6) setsid -f "$TERMINAL" -e "$EDITOR" "$0" ;;
esac

# Führe Update durch wenn nötig
[ -n "$updateme" ] && updateprice "$target" && \
    [ -n "$showupdate" ] && \
    notify-send "$icon Update abgeschlossen." "$name Preis ist jetzt \$$(cat "$pricefile")"

# Setze das LC_NUMERIC-Format für printf
LC_NUMERIC=C

# Formatiere und zeige Preis an
if [ -f "$pricefile" ]; then
	price="$(cat "$pricefile")"

	# Formatiere Preis: maximal 4 Ziffern gesamt
	formatted="$(awk -v p="$price" '
	BEGIN {
		integer_part = int(p)
		decimal_part = (p - integer_part) * 100

		# Wenn integer_part >= 10000 (5+ Stellen), zeige in K
		if (integer_part >= 10000) {
			kilo = p / 1000
			printf "%.1fK", kilo
		} else if (integer_part >= 1000) {
			# 4 Stellen: zeige nur Ganzzahl (z.B. 3764 statt 3764,46)
			printf "%\047d", integer_part
		} else if (integer_part >= 100) {
			# 3 Stellen: zeige 1 Dezimalstelle (z.B. 263.1)
			printf "%.1f", p
		} else if (integer_part >= 10) {
			# 2 Stellen: zeige 2 Dezimalstellen (z.B. 26.31)
			printf "%.2f", p
		} else {
			# 1 Stelle: zeige 3 Dezimalstellen (z.B. 1.234)
			printf "%.3f", p
		}
	}')"

	printf "%s%s%s\n" "$icon " "$formatted" "$symb"
fi
